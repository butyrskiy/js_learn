// ! PROMISE - объект, который используется для отложенных и асинхронных вычислений.
// ? Делает код более структурированным без сложной вложенности.
// ? Имеет одну точку выхода в ошибку. Можем вызывать сразу несколько асинхронных действий по цепочке, выполняя их друг за другом


// Todo. СОЗДАНИЕ ПРОМИСА
// ? Создаётся с помощью коструктора «new Promise»
// ? В качестве параметра принимает «callback»-функцию
// ? Callback в свою очередь принимает две функции:
// * «resolve», «reject»
// Todo. RESOLVE - говорит о том, что промис выполнился успешно
// Todo. REJECT - говорит о том, что промис выполнился НЕуспешно

// ? Мы можем представлять себе промис как некий ящик в котором выполняется какая-то асинхронная операция и по результатам её выполнения мы получим либо «RESOLVE», либо «REJECT» в случае ошибки

const promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve(Math.random()), 1000);
});

console.log(promise); // ? получим объект «promise» со статусом «pending». Это значит, что промис был объявлен, но ещё не был выполнен

// Todo. Для того чтобы ПОЛУЧИТЬ РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ ПРОМИСА мы должны вызвать у него метод «then»
// ? Метод «then» принимает два аргумента
// * Первый аргумент - callback-функция, которая выполнится, если промис выполнится УСПЕШНО
// * Второй аргумент - callback-функция, которая выполнится, если промис выполнится НЕуспешно
// Todo. Мы будем использовать только первый аргумент, потому что для обработки ошибок используем метод «catch»
// ? В первый аргумент будут переданы данные, которые были отправлены из промиса в функцию «RESOLVE»

// promise.then(x => console.log(x));

// * После этого статус промиса будет изменён на «fulfilled», то есть был выполнен успешно

// ! ВАЖНО. МЕТОД «THEN» позволяет строить цепочки вызовов, так как каждый «then» это также промис. При этом на каждой цепочке мы можем получать результат предыдущего «then».

promise.then(x => {
  console.log(x); 
  return x;
})
.then(y => console.log(y))
.catch(err => console.log(err)); 

// ? Таких цепочек может быть много и каждый «then» будет выполнен только после предыдущего.

// promise.then(z => console.log(z)); // получим результат

// ! Функции «resolve» и «reject» вызываются только ОДИН раз.
// ! В «resolve» и «reject» мы можем передать только один аргумент.


// Todo. МЕТОД «catch» (обработчик ошибок)
// ? Ставится последнем в цепочке вызовов. Если на любом из этапов работы промиса будет ошибка, то мы попадём в «catch»
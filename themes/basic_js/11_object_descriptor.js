// Todo. GETTER and SETTER дают возможность контролировать взаимодействией с каким-либо свойством и, например, не давать его перезаписать, удалить. Позволяет выводить свойство в более «читаемом» для обычного пользователя виде

// ! GETTER and SETTER НЕ копируются между объектами

const car = {
  brand: 'Audi',
  year: 2020,
}


// Todo. МЕТОД «Object.defineProperty()»
// ? Позволяет опеределить настройки для объекта и для конкретного свойства в нём
// ? Первый параметр - объект, который мы хотим конфигурировать. Второй параметр - либо новое свойство, либо уже существующее, которое мы хотим конфигурировать. Третий параметр - объект-дескриптор, который имеет настройки:
// * Настройка «configurable» - запрет на конфигурацию свойства. У свойства можно изменить значение, но нельзя, например, удалить
// * Настройка «enumerable» - делает свойство не итерируемым. Свойство не будет видно в цикле. Метод «oblect.keys», «oblect.values» также его не покажет
// * Настройка «writable» - запрещает перезапись свойства, но удалить его мы сможем

Object.defineProperty(car, 'year', {
  // * configurable: false,
  // * enumerable: false,
  // * writable: false,
})
// console.log(car);

for(key in car) {
  // console.log(key) // brand, если year настройки «enumerable: false»
}


// Todo. GETTER
// ? Синтаксис get связывает свойство объекта с функцией, которая будет вызываться при обращении к этому свойству.
// ? getter помогает скрыть какую-то логику приложения. Он является функцией, но используется как свойство, то есть без вызова(не так как вызывается метод с круглыми скобками)  

Object.defineProperty(car, 'age', {
  // * configurable: false,
  // * enumerable: false,
  // * writable: false,
  get: function() {
    return `Год производства автомобиля - ${this.year}`;
  }
})
// console.log(car);
// console.log(car.age); // Год производства автомобиля - 2019

// ? getter может быть объявлен не только через «Object.defineProperty», но и в самом объекте

const car2 = {
  brand: 'BMW',
  year: 2023,
  get label() {
    return `Марка автомобиля - ${this.brand}`;
  }
}

// console.log(car2.label); // Марка автомобиля - BMW
// console.log(car);


// Todo. SETTER
// ? setter также может быть объявлен не только через «Object.defineProperty», но и в самом объекте
// ? setter должен также называться как и getter
// ? Оператор set связывает свойство объекта с функцией, которая будет вызвана при попытке установить это свойство.

const car3 = {
  brand: 'Volkswagen',
  year: 2022,
  color: 'black',
  get label() {
    return `Марка автомобиля - ${this.brand}`;
  },
  set label(value) {
    this.brand = value; 
  }
}

car3.label = 'GM';
// console.log(car3); // {brand: 'GM', year: 2022, color: 'black'}


// ? Ситуация. Какая-то функция в большом коде записывает глобальную переменную, которая ломает весь код. Наша задача найти эту ошибку

// ? Решение. Объявляем «Object.defineProperty» на объект «window», на свойство «globalVar» и объявить дескриптор (в фигурных скобках). В дескрипторе задать «setter»
// ? можем «подписать» какое-то свойство и чекать как и кто будет записывать в него какие-то значения
Object.defineProperty(window, 'globalVar', {
   set: function(value) {
    console.log(value); // 10
    // debugger; // вызывает дебаггер
   }
})

// ? функция, которая всё ломает
function foo() {
  globalVar = 10;
}
foo();